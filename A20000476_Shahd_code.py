# -*- coding: utf-8 -*-
"""Untitled6.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1_ToohwFbNxBWAkqLYMZ5YQqdCNxViIC7

A20000476_Shahd Ahmed Maher Gawad
"""

pip install requests pandas

import requests
import pandas as pd
import numpy as np

# Set API key
API_KEY = 'f3da32164c1f48bea4e3bc17a3916325'
BASE_URL = 'https://api.rawg.io/api'

# Function get a limited number of games
def get_games(page_size=10):
    url = f"{BASE_URL}/games?key={API_KEY}&page_size={page_size}"
    response = requests.get(url)

    if response.status_code == 200:
        return response.json()['results']
    else:
        print(f"Failed to fetch data: {response.status_code}")
        return []

# 10 games data
games_data = get_games(page_size=10)

game_names = [game['name'] for game in games_data]

#number of users
num_users = 50

user_ratings = pd.DataFrame(index=[f'User_{i+1}' for i in range(num_users)], columns=game_names)

for user in user_ratings.index:
    for game in game_names:

        if np.random.rand() < 0.9:
            user_ratings.at[user, game] = np.random.randint(1, 6)  # Ratings from 1 to 5
        else:
            user_ratings.at[user, game] = np.nan


print("\nUser Ratings Matrix:")
print(user_ratings.to_string())
# Save the Data to a CSV file
user_ratings.to_csv('user_game_ratings.csv', index=True)

# Load the dataset
user_ratings = pd.read_csv('user_game_ratings.csv', index_col=0)

# Calculate the average rating for each game (column-wise average)
average_rating_per_game = user_ratings.mean()

# Calculate the average rating for each user (row-wise average)
average_rating_per_user = user_ratings.mean(axis=1)

# Display the results
print("Average rating per game:")
print(average_rating_per_game)

print("\nAverage rating per user:")
print(average_rating_per_user)

# Calculate the overall average rating, ignoring NaN values
overall_average_rating = user_ratings.stack().mean()
print(f"Overall average rating for the entire dataset: {overall_average_rating:.2f}")

import pandas as pd

# Load the existing user ratings dataset
user_ratings = pd.read_csv('user_game_ratings.csv', index_col=0)

# Calculate the average ratings for each user
average_ratings = user_ratings.mean(axis=1)

# Sort users by their average rating and get the top 10 users
top_10_users = average_ratings.sort_values(ascending=False).head(10)

# Print the top 10 users with their average ratings
print("Top 10 Users by Average Rating:")
print(top_10_users)

pip install scikit-surprise

import pandas as pd
import numpy as np

class UserBasedPearsonRecommender:
    def __init__(self, ratings_file):
        """
        User-based recommender system using Pearson correlation.

        Args:
            ratings_file (str): Path to the CSV file with user ratings.
        """
        self.ratings = pd.read_csv(ratings_file, index_col=0)
        self.ratings.fillna(0, inplace=True)  # Replace NaN with 0 for calculations

    def calculate_pearson(self, user1, user2):
        """
        Calculate Pearson correlation between two users.

        Args:
            user1: First user ID.
            user2: Second user ID.

        Returns:
            Pearson correlation coefficient.
        """
        common_items = self.ratings.loc[user1][self.ratings.loc[user1] > 0].index.intersection(
            self.ratings.loc[user2][self.ratings.loc[user2] > 0].index)

        if len(common_items) == 0:
            return 0

        user1_ratings = self.ratings.loc[user1, common_items]
        user2_ratings = self.ratings.loc[user2, common_items]

        return user1_ratings.corr(user2_ratings)

    def get_similar_users(self, target_user):
        """
        Get users similar to the target user.

        Args:
            target_user: User to find similar users for.

        Returns:
            Dictionary of similar users and their correlation scores.
        """
        similarities = {}
        for user in self.ratings.index:
            if user != target_user:
                similarity = self.calculate_pearson(target_user, user)
                similarities[user] = similarity

        return dict(sorted(similarities.items(), key=lambda x: x[1], reverse=True))

    def predict_rating(self, target_user, item):
        """
        Predict rating for an item using adjusted formula.

        Args:
            target_user: User to predict for.
            item: Item to predict rating for.

        Returns:
            Predicted rating.
        """
        similar_users = self.get_similar_users(target_user)

        target_user_ratings = self.ratings.loc[target_user]
        target_user_mean = target_user_ratings[target_user_ratings > 0].mean()

        numerator, denominator = 0, 0

        for other_user, similarity in similar_users.items():
            if similarity <= 0 or self.ratings.loc[other_user, item] == 0:
                continue

            other_user_ratings = self.ratings.loc[other_user]
            other_user_mean = other_user_ratings[other_user_ratings > 0].mean()

            deviation = self.ratings.loc[other_user, item] - other_user_mean
            numerator += similarity * deviation
            denominator += abs(similarity)

        if denominator == 0:
            return target_user_mean

        predicted_rating = target_user_mean + (numerator / denominator)

        return max(1, min(5, round(predicted_rating, 2)))  # assuming a 1-5 rating scale

    def create_prediction_matrix(self):
        """
        Create a matrix of predicted ratings for all users and items.

        Returns:
            DataFrame with predicted ratings.
        """
        prediction_matrix = pd.DataFrame(index=self.ratings.index, columns=self.ratings.columns)

        for user in self.ratings.index:
            for item in self.ratings.columns:
                prediction = self.predict_rating(user, item)
                prediction_matrix.loc[user, item] = prediction

        return prediction_matrix

    def calculate_mae_rmse(self, target_user):
        """
        Calculate Mean Absolute Error (MAE) and Root Mean Square Error (RMSE) for the target user.

        Args:
            target_user: User to calculate the metrics for.

        Returns:
            Tuple of (MAE, RMSE)
        """
        actual_ratings = self.ratings.loc[target_user].replace(0, np.nan).dropna()
        predicted_ratings = []

        for item in actual_ratings.index:
            prediction = self.predict_rating(target_user, item)
            predicted_ratings.append(prediction)

        # Calculate MAE and RMSE
        mae = np.mean(np.abs(actual_ratings - predicted_ratings))
        rmse = np.sqrt(np.mean((actual_ratings - predicted_ratings) ** 2))

        return round(mae, 2), round(rmse, 2)
#User-Based Pearson
if __name__ == "__main__":
    recommender = UserBasedPearsonRecommender('user_game_ratings.csv')


    prediction_matrix = recommender.create_prediction_matrix()
    print("\nPrediction Matrix:")
    print(prediction_matrix.to_string())


    target_user = 'User_1'
    # Calculate and print MAE and RMSE for the target user
    mae, rmse = recommender.calculate_mae_rmse(target_user)
    print(f"\nMean Absolute Error (MAE) for {target_user}: {mae}")
    print(f"Root Mean Square Error (RMSE) for {target_user}: {rmse}")

import pandas as pd
import numpy as np

class ItemBasedPearsonRecommender:
    def __init__(self, ratings_file):
        """
        Item-based recommender system using Pearson correlation.

        Args:
            ratings_file (str): Path to the CSV file with user ratings.
        """
        self.ratings = pd.read_csv(ratings_file, index_col=0)
        self.ratings.fillna(0, inplace=True)  # Replace NaN with 0 for calculations

    def calculate_pearson(self, item1, item2):
        """
        Calculate Pearson correlation between two items.

        Args:
            item1: First item ID.
            item2: Second item ID.

        Returns:
            Pearson correlation coefficient.
        """
        common_users = self.ratings.loc[:, item1][self.ratings.loc[:, item1] > 0].index.intersection(
            self.ratings.loc[:, item2][self.ratings.loc[:, item2] > 0].index)

        if len(common_users) == 0:
            return 0

        item1_ratings = self.ratings.loc[common_users, item1]
        item2_ratings = self.ratings.loc[common_users, item2]

        return item1_ratings.corr(item2_ratings)

    def get_similar_items(self, target_item):
        """
        Get items similar to the target item.

        Args:
            target_item: Item to find similar items for.

        Returns:
            Dictionary of similar items and their correlation scores.
        """
        similarities = {}
        for item in self.ratings.columns:
            if item != target_item:
                similarity = self.calculate_pearson(target_item, item)
                similarities[item] = similarity

        return dict(sorted(similarities.items(), key=lambda x: x[1], reverse=True))

    def predict_rating(self, target_user, item):
        """
        Predict rating for an item using adjusted formula.

        Args:
            target_user: User to predict for.
            item: Item to predict rating for.

        Returns:
            Predicted rating.
        """
        similar_items = self.get_similar_items(item)


        user_ratings = self.ratings.loc[target_user]
        user_mean_rating = user_ratings[user_ratings > 0].mean()

        numerator, denominator = 0, 0


        for other_item, similarity in similar_items.items():
            if similarity <= 0 or self.ratings.loc[target_user, other_item] == 0:
                continue

            other_item_ratings = self.ratings[other_item][self.ratings[other_item] > 0]
            other_item_mean = other_item_ratings.mean()

            deviation = self.ratings.loc[target_user, other_item] - other_item_mean
            numerator += similarity * deviation
            denominator += abs(similarity)

        if denominator == 0:
            return user_mean_rating
        predicted_rating = user_mean_rating + (numerator / denominator)
        return max(1, min(5, round(predicted_rating, 2)))  # assuming a 1-5 rating scale

    def create_prediction_matrix(self):
        """
        Create a matrix of predicted ratings for all users and items.

        Returns:
            DataFrame with predicted ratings.
        """
        prediction_matrix = pd.DataFrame(index=self.ratings.index, columns=self.ratings.columns)

        for user in self.ratings.index:
            for item in self.ratings.columns:
                prediction = self.predict_rating(user, item)
                prediction_matrix.loc[user, item] = prediction

        return prediction_matrix

    def calculate_mae_rmse(self, target_user):
        """
        Calculate Mean Absolute Error (MAE) and Root Mean Square Error (RMSE) for the target user.

        Args:
            target_user: User to calculate the metrics for.

        Returns:
            Tuple of (MAE, RMSE)
        """
        actual_ratings = self.ratings.loc[target_user].replace(0, np.nan).dropna()
        predicted_ratings = []

        for item in actual_ratings.index:
            prediction = self.predict_rating(target_user, item)
            predicted_ratings.append(prediction)

        # Calculate MAE and RMSE
        mae = np.mean(np.abs(actual_ratings - predicted_ratings))
        rmse = np.sqrt(np.mean((actual_ratings - predicted_ratings) ** 2))

        return round(mae, 2), round(rmse, 2)

#Item-Based Pearson
if __name__ == "__main__":
    recommender = ItemBasedPearsonRecommender('user_game_ratings.csv')


    prediction_matrix = recommender.create_prediction_matrix()
    print("\nPrediction Matrix:")
    print(prediction_matrix.to_string())


    target_user = 'User_1'

    # Calculate and print MAE and RMSE for the target user
    mae, rmse = recommender.calculate_mae_rmse(target_user)
    print(f"\nMean Absolute Error (MAE) for {target_user}: {mae}")
    print(f"Root Mean Square Error (RMSE) for {target_user}: {rmse}")

import pandas as pd
import numpy as np
from sklearn.metrics.pairwise import cosine_similarity

class UserBasedCosineRecommender:
    def __init__(self, ratings_file):
        """
        User-based recommender system using cosine similarity.

        Args:
            ratings_file (str): Path to the CSV file with user ratings.
        """
        self.ratings = pd.read_csv(ratings_file, index_col=0)
        self.ratings.fillna(0, inplace=True)  # Replace NaN with 0 for calculations
        self.similarity_matrix = cosine_similarity(self.ratings)
        self.similarity_matrix_df = pd.DataFrame(self.similarity_matrix, index=self.ratings.index, columns=self.ratings.index)

    def get_similar_users(self, target_user):
        """
        Get users similar to the target user.

        Args:
            target_user: User to find similar users for.

        Returns:
            Dictionary of similar users and their cosine similarity scores.
        """
        similar_users = self.similarity_matrix_df[target_user].drop(target_user)
        return similar_users.sort_values(ascending=False).to_dict()

    def predict_rating(self, target_user, item):
        """
        Predict rating for an item.

        Args:
            target_user: User to predict for.
            item: Item to predict rating for.

        Returns:
            Predicted rating.
        """
        similar_users = self.get_similar_users(target_user)
        total_similarity = sum([sim for u, sim in similar_users.items() if self.ratings.loc[u, item] > 0])

        if total_similarity == 0:
            return 0

        weighted_ratings = sum([self.ratings.loc[u, item] * sim for u, sim in similar_users.items() if self.ratings.loc[u, item] > 0])

        return weighted_ratings / total_similarity if total_similarity != 0 else 0

    def create_prediction_matrix(self):
        """
        Create a matrix of predicted ratings for all users and items.

        Returns:
            DataFrame with predicted ratings.
        """
        prediction_matrix = pd.DataFrame(index=self.ratings.index, columns=self.ratings.columns)

        for user in self.ratings.index:
            for item in self.ratings.columns:
                prediction = self.predict_rating(user, item)
                prediction_matrix.loc[user, item] = round(prediction, 2)

        return prediction_matrix

    def calculate_mae_rmse(self, target_user):
        """
        Calculate Mean Absolute Error (MAE) and Root Mean Square Error (RMSE) for the target user.

        Args:
            target_user: User to calculate the metrics for.

        Returns:
            Tuple of (MAE, RMSE)
        """
        actual_ratings = self.ratings.loc[target_user].replace(0, np.nan).dropna()
        predicted_ratings = []

        for item in actual_ratings.index:
            prediction = self.predict_rating(target_user, item)
            predicted_ratings.append(prediction)

        # Calculate MAE
        mae = np.mean(np.abs(actual_ratings - predicted_ratings))

        # Calculate RMSE
        rmse = np.sqrt(np.mean((actual_ratings - predicted_ratings) ** 2))

        return round(mae, 2), round(rmse, 2)

# User-Based Cosine
if __name__ == "__main__":
    recommender = UserBasedCosineRecommender('user_game_ratings.csv')


    prediction_matrix = recommender.create_prediction_matrix()
    print("\nPrediction Matrix:")
    print(prediction_matrix.to_string())


    target_user = 'User_1'

    # Calculate and print MAE and RMSE for the target user
    mae, rmse = recommender.calculate_mae_rmse(target_user)
    print(f"\nMean Absolute Error (MAE) for {target_user}: {mae}")
    print(f"Root Mean Square Error (RMSE) for {target_user}: {rmse}")

import pandas as pd
import numpy as np
from sklearn.metrics.pairwise import cosine_similarity

class ItemBasedCosineRecommender:
    def __init__(self, ratings_file):
        """
        Item-based recommender system using cosine similarity.

        Args:
            ratings_file (str): Path to the CSV file with user ratings.
        """
        self.ratings = pd.read_csv(ratings_file, index_col=0)
        self.ratings.fillna(0, inplace=True)  # Replace NaN with 0 for calculations
        self.similarity_matrix = cosine_similarity(self.ratings.T)
        self.similarity_matrix_df = pd.DataFrame(self.similarity_matrix, index=self.ratings.columns, columns=self.ratings.columns)

    def get_similar_items(self, target_item):
        """
        Get items similar to the target item.

        Args:
            target_item: Item to find similar items for.

        Returns:
            Dictionary of similar items and their cosine similarity scores.
        """
        similar_items = self.similarity_matrix_df[target_item].drop(target_item)
        return similar_items.sort_values(ascending=False).to_dict()

    def predict_rating(self, target_user, item):
        """
        Predict rating for an item.

        Args:
            target_user: User to predict for.
            item: Item to predict rating for.

        Returns:
            Predicted rating.
        """
        similar_items = self.get_similar_items(item)
        total_similarity = sum([sim for i, sim in similar_items.items() if self.ratings.loc[target_user, i] > 0])

        if total_similarity == 0:
            return 0

        weighted_ratings = sum([self.ratings.loc[target_user, i] * sim for i, sim in similar_items.items() if self.ratings.loc[target_user, i] > 0])

        return weighted_ratings / total_similarity if total_similarity != 0 else 0

    def create_prediction_matrix(self):
        """
        Create a matrix of predicted ratings for all users and items.

        Returns:
            DataFrame with predicted ratings.
        """
        prediction_matrix = pd.DataFrame(index=self.ratings.index, columns=self.ratings.columns)

        for user in self.ratings.index:
            for item in self.ratings.columns:
                prediction = self.predict_rating(user, item)
                prediction_matrix.loc[user, item] = round(prediction, 2)

        return prediction_matrix

    def calculate_mae_rmse(self, target_user):
        """
        Calculate Mean Absolute Error (MAE) and Root Mean Square Error (RMSE) for the target user.

        Args:
            target_user: User to calculate the metrics for.

        Returns:
            Tuple of (MAE, RMSE)
        """
        actual_ratings = self.ratings.loc[target_user].replace(0, np.nan).dropna()
        predicted_ratings = []

        for item in actual_ratings.index:
            prediction = self.predict_rating(target_user, item)
            predicted_ratings.append(prediction)

        # Calculate MAE
        mae = np.mean(np.abs(actual_ratings - predicted_ratings))

        # Calculate RMSE
        rmse = np.sqrt(np.mean((actual_ratings - predicted_ratings) ** 2))

        return round(mae, 2), round(rmse, 2)

# Item-Based Cosine
if __name__ == "__main__":
    recommender = ItemBasedCosineRecommender('user_game_ratings.csv')


    prediction_matrix = recommender.create_prediction_matrix()
    print("\nPrediction Matrix:")
    print(prediction_matrix.to_string())


    target_user = 'User_1'

    # Calculate and print MAE and RMSE for the target user
    mae, rmse = recommender.calculate_mae_rmse(target_user)
    print(f"\nMean Absolute Error (MAE) for {target_user}: {mae}")
    print(f"Root Mean Square Error (RMSE) for {target_user}: {rmse}")

